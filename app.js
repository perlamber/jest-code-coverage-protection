'use strict'

const { program } = require('commander');
const fs = require('fs')

const app = {
  run() {
    program
      .version('1.1.3')
      .description('Compare coverage-summary.json generated by jest')
      .option('-f, --file <filename>', 'The file generated by the (feature) branch you want to check', 'coverage/coverage-summary.json')
      .option('-c, --compare <filename>', 'The file generate by the (master) branch you want to compare against', 'master/coverage/coverage-summary.json')
      .option('-n, --new <threshold','The minimal threshold new code should have', '0.70')
      .option('-v, --variance <variance>','Allow for variance, e.g. allow 0.05 to allow a 5% decrease', '0')
      .option('-p, --projectpath <projectpath>','The path to the project from within the workspace, if passed makes possible compare summaries built in different workspaces', '')
    program.parse(process.argv);
    const options = program.opts();
    const files = {};

    console.info(`##Jest Coverage Partial Compare ## Version: ${options['version']}`);

    ['file', 'compare'].forEach((key, index) => {
      try {
        files[key] = JSON.parse(fs.readFileSync(options[key]));
      } catch(err) {
        if('file' == key){
          if( err.message.indexOf("ENOENT: no such file or directory") != -1)
          {
            console.info(`No statistics to check at this time. ${options[key]} was not found.`);
            process.exit(0);  
          }
          console.error(err);
          process.exit(1);  
        }
        else{
          console.error(err);
          process.exit(1);
        }
      }
    })

    const {file, compare} = files;
    let exitCode = 0;
    const minCov = parseFloat(options.new*100);

    if (options.variance!='0') {
      console.log(`Allowed variance is ${options.variance}`);
    }

    let compareBasePath;
    let fileBasePath;
    if(options['projectpath'])
    {
      compareBasePath = this.getBasePathByProjectPath(compare, options['projectpath']);
      fileBasePath = this.getBasePathByProjectPath(file, options['projectpath']);
    }

    Object.keys(file).forEach((mkey) => {
      if(mkey!='total'){
        let compareKey = mkey;
        if(compareBasePath && fileBasePath) {
          compareKey = mkey.replace(fileBasePath, compareBasePath);
        }
        ['lines','branches'].forEach((key) => {
          let compareEntry = compare[compareKey];
          if(!compareEntry) {
            const pctNewDiff = parseFloat(file[mkey][key].pct).toFixed(2) + parseFloat(options.variance);
            if (parseFloat(pctNewDiff) < parseFloat(options.new)) {
              console.error(`Yikes, coverage for ${key} in ${mkey} is outside of limits, is currently ${file[mkey][key].pct}`);
              exitCode = 1;
            }
          }
          else {
            const totDiff = file[mkey][key].total - compareEntry[key].total; // Difference between lines
            const pctDiff = (compareEntry[key].pct - parseFloat(file[mkey][key].pct).toFixed(2));
            if (parseFloat(pctDiff) > parseFloat(options.variance) && totDiff >= 0) {
              console.error(`Yikes, coverage for ${mkey} ${key} outside of limits, went from ${compareEntry[key].pct} to ${file[mkey][key].pct}`);
              exitCode = 1;
            }
            
            if (totDiff>0) { //If there is a difference between the total lines of this file
              const coverageDiff = file[mkey][key].covered - compareEntry[key].covered; // e.g. 18
              const newCoveragePct = parseFloat(coverageDiff / totDiff * 100);
              if (newCoveragePct < minCov) {
                console.error(`Yikes, coverage for ${mkey} ${key} outside of limits, new code coverage is ${newCoveragePct}, was expecting at least ${minCov}`);
                exitCode = 1;
              }
            }
          }
        });
      }  
    });
    console.info(`Coverage check is completed.`);
    if(exitCode > 0)
    {
      console.info(`Something went wrong, check the logs for more info.`);
    } else {
      console.info(`All the checks have passed succesfully.`);
    }
    process.exit(exitCode);
  },
  getBasePathByProjectPath: function(compareObj, projectPath)
  {
    let basePath = '';
    const compareObjKeys = Object.keys(compareObj);
    for(var i = 0; i < compareObjKeys.length; i++){
      if(compareObjKeys[i]!='total'){
        basePath = compareObjKeys[i].substring(0,compareObjKeys[i].indexOf(projectPath));
        break;
      }
    }
    return basePath;
  }
}

module.exports = app;
